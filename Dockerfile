# Use Alpine Linux as the base image
FROM alpine:latest

# Install Python 3, Java, PostgreSQL, pip, nano, bash, and other necessary dependencies
RUN apk --no-cache add python3 openjdk11-jre postgresql py3-pip nano build-base python3-dev py3-numpy py3-six py3-wheel bash openssh curl

# Create a Python virtual environment and activate it
RUN python3 -m venv /venv
ENV PATH="/venv/bin:$PATH"

# Upgrade pip and install setuptools
RUN /venv/bin/pip install --upgrade pip setuptools

# Install PySpark within the virtual environment
RUN /venv/bin/pip install pyspark

# Configure PostgreSQL
RUN mkdir -p /run/postgresql/ && chown -R postgres:postgres /run/postgresql/

#download PostgreSQL driver
RUN curl -SL https://jdbc.postgresql.org/download/postgresql-42.3.4.jar -o /venv/lib/postgresql-jdbc.jar

# Configure SSH
RUN apk add --no-cache openssh \
  && ssh-keygen -A \
  && echo "root:pyspark_postgres" | chpasswd \
  && sed -i 's/#PermitRootLogin prohibit-password/PermitRootLogin yes/' /etc/ssh/sshd_config \
  && sed -i 's/#PasswordAuthentication yes/PasswordAuthentication yes/' /etc/ssh/sshd_config

EXPOSE 22

USER postgres
RUN initdb -D /var/lib/postgresql/data
RUN echo "host all all 0.0.0.0/0 trust" >> /var/lib/postgresql/data/pg_hba.conf
RUN echo "listen_addresses='*'" >> /var/lib/postgresql/data/postgresql.conf
EXPOSE 5432

# Preconfigure PostgreSQL with databases and schemas
RUN pg_ctl -D /var/lib/postgresql/data start && \
  psql --command "ALTER USER postgres WITH PASSWORD 'pyspark_postgres';" && \
  psql --dbname=postgres --command "CREATE SCHEMA IF NOT EXISTS staging;" && \
  psql --dbname=postgres --command "CREATE SCHEMA IF NOT EXISTS production;" && \
  psql --dbname=postgres --command "CREATE SCHEMA IF NOT EXISTS domain_tables;" && \
  psql --dbname=postgres --command "CREATE SCHEMA IF NOT EXISTS public;" && \
  psql --command "ALTER USER postgres WITH SUPERUSER;" && \
  psql --dbname=postgres --command "GRANT ALL PRIVILEGES ON DATABASE postgres TO postgres;" && \
  psql --dbname=postgres --command "GRANT ALL PRIVILEGES ON SCHEMA staging TO postgres;" && \
  psql --dbname=postgres --command "GRANT ALL PRIVILEGES ON SCHEMA production TO postgres;" && \
  psql --dbname=postgres --command "GRANT ALL PRIVILEGES ON SCHEMA domain_tables TO postgres;" && \
  psql --dbname=postgres --command "GRANT ALL PRIVILEGES ON SCHEMA public TO postgres;" && \
  psql --dbname=postgres --command "CREATE TABLE staging.test (  id int4 NOT NULL,  nome varchar NOT NULL,  valore varchar NOT NULL);" && \
  psql --dbname=postgres --command "INSERT INTO staging.test (id, nome, valore) VALUES (1, 'pippo', '10'), (2, 'pluto', '20'), (3, 'paperino', '30');"


USER root

# Environment variables for PySpark
ENV PYSPARK_PYTHON=python3
ENV PYSPARK_DRIVER_PYTHON=python3

# Add Spark path to the PATH environment variable
ENV SPARK_HOME=/venv/lib/python3.12/site-packages/pyspark
ENV PATH=$SPARK_HOME/bin:$PATH

# Create the /ps_data directory structure with /jobs, /input, /output, /classes folders
RUN mkdir -p /ps_data/jobs /ps_data/input /ps_data/output /ps_data/classes

#Create the classes
RUN echo -e "##########################################################################################################\n#\n# NOTE:\n# impegare come nel seguente esempio:\n#\n# import df_s3_other_functions\n# UOF = df_s3_other_functions.functions(dframe=self._df, imps={'ps_functions': PSF, 'ps_types': None, 'regex': None})\n# \n# UOF.fixCol('cognome')\n#\n##########################################################################################################\n\nclass functions:\n\n    def __init__(self,dframe, imps = {'ps_functions':None,'ps_types':None,'regex':None}):\n        \n        if imps['ps_functions'] is None: \n            import pyspark.sql.functions as imps_ps_functions\n            imps['ps_functions'] = imps_ps_functions\n        if imps['ps_types'] is None: \n            import pyspark.sql.types as imps_ps_types\n            imps['ps_types'] = imps_ps_types\n        if imps['regex'] is None: \n            import re as imps_regex\n            imps['regex'] = imps_regex\n        \n        self.dframe = dframe\n        self.imps = imps\n\n\n    #ottieni datatype di un attributo\n    def dType(self,colname):  \n\n        coltype = None\n        for field in self.dframe.schema.fields:\n            if field.name == colname:\n                coltype = field.dataType\n                break\n                \n        return coltype\n        \n    ##########################################################################################################\n          \n    #ARGOMENTO   | DEFAULT                       | DATATYPE ATTRB.  | DATATYPE APPLCZ. |DESCRIZIONE\n    #-----------------------------------------------------------------------------------------------------------------\n    #colname     |                               |str               | *                | nome colonna nel dataframe\n    #collength   | None                          |int               | *                | limite substring e padding\n    #padval      | None                          |str               | *                | valore del padding\n    #padpos      | 'r'                           |str               | *                | posizione del padding ('r'/'l')\n    #placeholder | None                          |str               | *                | valore di coalescing, applicato \n    #colformat   | None/yyyy-MM-dd/['S','N']     |str/str/arr[str]  | num/date/bool    | formattazione numero/data/booleano \n    #coltrim     | False                         |bool              | str              | trim della stringa originale\n    #stringcast  | False                         |bool              | *                | cast preventivo dell'attributo a stringa \n    #remempty    | False                         |bool              | str              | i valori '' sono convertiti a null\n    #typeraise   | True                          |bool              | *                | solleva errore se datatype non supportato\n    #skipcheck   | False                         |bool              | *                | salta verifiche su argomenti \n        \n    ##########################################################################################################\n     \n    def fixCol(self,colname,collength = None,padval = None,padpos = 'r',placeholder = None,colformat = None,coltrim = False,stringcast = False,remempty = False,typeraise = True,skipcheck = False):\n          \n        colres = self.imps['ps_functions'].col(colname)\n        coltype = self.dType(colname)\n        \n        #applica padding e substring (solo tipo str)\n        def addpad(colres,collength,padval,padpos,do_substr = True):\n        \n            #verifiche\n            if not skipcheck:\n                #verifica padpos\n                if padpos is not None and padpos not in ['l','r']:\n                    raise ValueError('Valore di padding non supportato \n valori support.: \'r\',\'l\'')\n                #verifica collength\n                if collength is not None and (not isinstance(collength,int) or collength < 0):\n                    raise ValueError('Valore di lunghezza stringa non supportato \n valori support.: int > 0')\n        \n            if collength is not None and collength > 0:\n            \n                #coalesce con vuoto\n                colres = self.imps['ps_functions'].coalesce(colres,self.imps['ps_functions'].lit(''))\n                \n                #applica substring\n                if do_substr: \n                    colres = self.imps['ps_functions'].substring(colres,1,collength)\n                    \n                #applica padding\n                if padval is not None: \n                    if padpos == 'r':\n                        colres = self.imps['ps_functions'].rpad(colres,collength,padval)\n                    elif padpos == 'l':\n                        colres = self.imps['ps_functions'].lpad(colres,collength,padval)\n            return colres\n            \n          \n        #applica placeholder di tipo stringa (solo tipo str)\n        def addphs(colres,placeholder,dftph = True):\n        \n            #verifiche\n            if not skipcheck:\n            \n                #verifica placeholder\n                if placeholder is not None:\n                    if not isinstance(placeholder,str):\n                        raise TypeError(f\"placeholder \\"{placeholder}\\" non Ã¨ di tipo stringa \n placeholder sugg.: \'\'\")\n        \n            #placeholder di default se non fornito\n            if placeholder is None and dftph == True:\n                placeholder = ''\n                       \n            #applica placeholder\n            if placeholder is not None:\n                colres = self.imps['ps_functions'].when((colres.isNull()),self.imps['ps_functions'].lit(placeholder)).otherwise(colres)\n      \n            \n            return colres\n         \n         \n        #stringa o castato a stringa\n        if isinstance(coltype, self.imps['ps_types'].StringType) or stringcast:\n        \n            if stringcast and not isinstance(coltype, self.imps['ps_types'].StringType): colres = colres.cast('string')\n            if coltrim: colres = self.imps['ps_functions'].when(colres.isNotNull(),self.imps['ps_functions'].trim(colres)).otherwise(colres) \n            if remempty: colres = self.imps['ps_functions'].when(self.imps['ps_functions'].length(colres) == 0,self.imps['ps_functions'].lit(None)).otherwise(colres)\n             \n            #applica placeholder tipo stringa o valore vuoto\n            colres = addphs(colres,placeholder)\n            \n            #applica padding e substr\n            colres = addpad(colres,collength,padval,padpos)\n         \n         \n        #timestamp/data\n        elif isinstance(coltype, (self.imps['ps_types'].TimestampType,self.imps['ps_types'].DateType)):\n            \n            #valore formattazione custom\n            colformat = colformat if colformat is not None else 'yyyy-MM-dd'\n            \n            #formatta data\n            colres = self.imps['ps_functions'].when(colres.isNotNull(),self.imps['ps_functions'].date_format(colres,colformat))\n            \n            #cast a stringa\n            colres = colres.cast('string')\n            \n            ##applica placeholder tipo stringa o valore vuoto\n            colres = addphs(colres,placeholder)\n            \n            #applica padding e substr\n            colres = addpad(colres,collength,padval,padpos)\n\n                   \n        #booleano\n        elif isinstance(coltype, self.imps['ps_types'].BooleanType):\n        \n            #verifiche\n            if not skipcheck:\n            \n                #verifica colformat\n                if colformat is not None and (not isinstance(colformat, list) or not len(colformat) == 2):\n                    raise ValueError(\"formatt. non valida. \n formatt. sugg.: ['S','N']\")\n        \n            #valori formattazione default\n            colformat = colformat if colformat is not None else ['S','N']\n            \n            #conversione\n            colres = self.imps['ps_functions'].when(colres.isNull(),self.imps['ps_functions'].lit(placeholder)).when(colres == True,self.imps['ps_functions'].lit(colformat[0])).otherwise(self.imps['ps_functions'].lit(colformat[1]))\n            \n            #cast a stringa\n            colres = colres.cast('string')\n            \n            #applica placeholder tipo stringa o valore vuoto\n            colres = addphs(colres,placeholder)\n            \n            #applica padding\n            colres = addpad(colres,collength,padval,padpos,False)\n            \n                                    \n        #numerico\n        elif isinstance(coltype, (self.imps['ps_types'].IntegerType,self.imps['ps_types'].LongType,self.imps['ps_types'].DoubleType,self.imps['ps_types'].DecimalType)):\n        \n            #TODO: ARROTONDAMENTO/TRONCAMENTO\n            #NOTA: i decimal vengono convertiti a double, dunque troncati oltre una certa cifra\n\n            #cast decimal a double\n            if isinstance(coltype, self.imps['ps_types'].DecimalType):\n                colres = colres.cast('double')\n                \n            #verifiche varie\n            if not skipcheck:\n            \n                #verifica placeholder\n                if placeholder is not None:\n                    if (isinstance(coltype, (self.imps['ps_types'].IntegerType,self.imps['ps_types'].LongType)) and not isinstance(placeholder,(int,str))):\n                        raise TypeError(f\"placeholder \\"{placeholder}\\" non Ã¨ di tipo {coltype} o stringa \n placeholder sugg.: 0\")\n                    if (isinstance(coltype, (self.imps['ps_types'].DoubleType, self.imps['ps_types'].DecimalType)) and not isinstance(placeholder,(float,str))): \n                        raise TypeError(f\"placeholder \\"{placeholder}\\" non Ã¨ di tipo {coltype} o stringa \n placeholder sugg.: 0.0\")\n            \n                #verifica stringa formattazione\n                if colformat is not None:\n                       \n                    #verifica caratteri generici\n                    if '%' not in colformat:\n                        raise ValueError(\"colformat non comprende \\"%\\", per estrazione a stringa\")\n                        \n                    #verifica interi\n                    if isinstance(coltype, (self.imps['ps_types'].IntegerType,self.imps['ps_types'].LongType)): \n                    \n                         #info db\n                        maxlen = self.dframe.select(self.imps['ps_functions'].max(self.imps['ps_functions'].length(self.imps['ps_functions'].coalesce(self.imps['ps_functions'].col(colname).cast('string'),self.imps['ps_functions'].lit(''))))).head()[0] #lunghezza massima intero\n                        frmsugg = ('%0' + str(maxlen) + 'd')\n                        \n                        #verifica caratteri\n                        if ('.' in colformat or 'f' in colformat or 'd' not in colformat):\n                            raise ValueError(f\"colformat \\"{colformat}\\" non valido per tipo {coltype} \n formatt. sugg.: {frmsugg}\")\n                        \n                        #verifica caratteri (cifre + separatore)                \n                        maxlen1 = self.dframe.select(self.imps['ps_functions'].max(self.imps['ps_functions'].length(self.imps['ps_functions'].col(colname)))).head()[0] #lunghezza massima intero in df\n                        frmlen1 = self.imps['regex'].search(r'%0?(\d+)d', colformat)\n                        if frmlen1: frmlen1 = int(frmlen1.group(1))\n                        else: raise ValueError(f\"colformat \\"{colformat}\\" non valido per tipo {coltype}\")\n                        if frmlen1 < maxlen1 : raise ValueError(f\"carat. colformat \\"{colformat}\\" non sufficienti \n carat. max df: {maxlen1} \n carat. formatt: {frmlen1} \n formatt. min. sugg.: {frmsugg}\")\n                            \n                    #verifica float\n                    if isinstance(coltype, (self.imps['ps_types'].DoubleType,self.imps['ps_types'].DecimalType)):\n                    \n                        #info db\n                        maxlen = self.dframe.select(self.imps['ps_functions'].max(self.imps['ps_functions'].length(self.imps['ps_functions'].regexp_replace(self.imps['ps_functions'].format_string('%f',self.imps['ps_functions'].col(colname).cast('double')),r'\.?0+$|(^null$)', '')))).head()[0] #lunghezza massima p.intera+separatore+decimale in df\n                        maxlen2 = self.dframe.select(self.imps['ps_functions'].max(self.imps['ps_functions'].length(self.imps['ps_functions'].coalesce(self.imps['ps_functions'].split(self.imps['ps_functions'].regexp_replace(self.imps['ps_functions'].format_string('%f',self.imps['ps_functions'].col(colname).cast('double')),r'\.?0+$', ''), \"\\.\").getItem(1),self.imps['ps_functions'].lit(''))))).head()[0] #lunghezza massima parte decimale in df\n                        maxlen1 = maxlen - maxlen2 - 1 #lunghezza massima parte intera in df\n                        frmsugg = ('%0' + str(maxlen) + '.' + str(maxlen2) + 'f')\n                    \n                        #verifica caratteri\n                        if ('d' in colformat or 'f' not in colformat or '.' not in colformat):\n                            raise ValueError(f\"formatt. \\"{colformat}\\" non valida per tipo {coltype} \n formatt. sugg.: {frmsugg}\")\n                        \n                        #verifica formattazione                \n                        frmlen = self.imps['regex'].search(r'%0?(\d+)\.(\d+)f', colformat)\n                        if frmlen: \n                            frmlen2 = int(frmlen.group(2)) #lunghezza parte decimale in formattazione\n                            frmlen = int(frmlen.group(1)) #lunghezza massima p.intera+separatore+decimale in formattazione\n                            frmlen1 = frmlen - frmlen2 - 1 #lunghezza parte intera in formattazione\n                        else: raise ValueError(f\"formatt. \\"{colformat}\\" non valida per tipo {coltype} \n formatt. sugg.: {frmsugg}\") \n                        if frmlen < maxlen : raise ValueError(f\"carat. totali colformat \\"{colformat}\\" non sufficienti \n carat. max df: {maxlen} \n carat. formatt: {frmlen} \n formatt. min. sugg.: {frmsugg}\")\n                        if frmlen1 < maxlen1 : raise ValueError(f\"carat. parte intera formatt. \\"{colformat}\\" non sufficienti \n carat. max df: {maxlen1} \n carat. formatt: {frmlen1} \n formatt. sugg.: {frmsugg}\")\n                        #if frmlen2 != maxlen2 : raise ValueError(f\"carat. parte decimale formatt. \\"{colformat}\\" maggiore delle massime presenti \n carat. max df: {maxlen2} \n carat. formatt: {frmlen2} \n formatt. sugg.: {frmsugg}\")\n                                     \n            #applica placeholder tipo numerico\n            if placeholder is not None and isinstance(placeholder,(int,float)):\n                colres = self.imps['ps_functions'].coalesce(colres,self.imps['ps_functions'].lit(placeholder))\n                    \n            #formatta numero a stringa\n            if colformat is not None:\n                colres = self.imps['ps_functions'].when(colres.isNotNull(),self.imps['ps_functions'].format_string(colformat,colres)).otherwise(colres.cast('string'))\n            \n            #cast a stringa\n            colres = colres.cast('string')\n                    \n            #applica placeholder tipo stringa o valore vuoto\n            if placeholder is None or (placeholder is not None and isinstance(placeholder,str)):\n                colres = addphs(colres,placeholder)\n                           \n            #applica padding (no substr)\n            colres = addpad(colres,collength,padval,padpos,False)\n        \n      \n        #datatype non supportato\n        elif typeraise: \n            raise TypeError(f\"tipo non supportato: {coltype}\")\n                               \n        return colres\n\n\n\n    ##########################################################################################################\n" > /ps_data/classes/df_s3_other_functions.py

# Create the test.py script in the /ps_data/jobs directory
RUN echo -e "\n#import principali\nimport sys\nimport os\n\n#parametri\noutput_path = \"/ps_data/output/\"\noutput_name = \"test\"\noutput_ext = \".txt\"\n\n# Importa librerie Spark\nfrom pyspark.sql import SparkSession\nfrom pyspark.sql.types import StringType\nimport pyspark.sql.functions as PSF\n\n#importa altre classi\nsys.path.append(os.path.abspath(\"../classes\"))\nimport df_s3_other_functions\n\n# Crea sessione Spark\nspark = SparkSession.builder.appName(\"DatasetProva\").config(\"spark.jars\",\"/venv/lib/postgresql-jdbc.jar\") .getOrCreate()\n\n#connetti a pg ed estrai\ndef table2df(table_name, database=\"postgres\", user=\"postgres\", password=\"\"):\n    df = spark.read.format(\"jdbc\").option(\"url\", \"jdbc:postgresql://localhost:5432/\"+database).option(\"dbtable\", table_name).option(\"user\", user).option(\"password\", password).option(\"driver\", \"org.postgresql.Driver\").load()\n    return df\n\n# Crea un dataframe di prova con dati numerici e stringhe\ndata = [\n    (1, \"Valore1\", 10.0),\n    (2, \"Valore2\", 20.0),\n    (3, \"Valore3\", 30.0),\n]\ncolumns = [\"id\", \"nome\", \"valore\"]\ndf = spark.createDataFrame(data,columns)\n\ndf = table2df(\"staging.test\")\n\n#etl\nUOF = df_s3_other_functions.functions(dframe=df, imps={\"ps_functions\": PSF, \"ps_types\": None, \"regex\": None})\nseparator = PSF.lit(\"|\")\ndf = df.select(PSF.concat(\n        PSF.col(\"id\").cast(\"string\"),separator,\n        PSF.col(\"nome\").cast(\"string\"),separator,\n        PSF.col(\"valore\").cast(\"string\"),separator\n).alias(\"value\"))\n\n\n#Salva il dataframe nella path specificata\noutput_df = df.coalesce(1)\noutput_df.write.mode('overwrite').text(output_path + output_name)\n\nprint(\"generato file di output sotto \" + output_path + output_name)" > /ps_data/jobs/test.py

# Automatically activate the Python virtual environment upon SSH login
RUN echo "source /venv/bin/activate" >> /etc/profile

# Start PostgreSQL and SSH, and keep them running
CMD ["sh", "-c", "su postgres -c 'pg_ctl -D /var/lib/postgresql/data start' && /usr/sbin/sshd && tail -f /dev/null"]
